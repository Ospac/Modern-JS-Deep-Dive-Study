# 26장 ES6 함수의 추가 기능
## 26.1 함수의 구분

ES6 이전의 모든 함수는 같은 형태로 일반함수로서 호출(callable), 생성자 함수로서 호출(constructor) 가능하다. 실수를 유발할 수 있다.
```js
var foo = function () {
  return 1;
};

// 일반적인 함수로서 호출
foo(); // -> 1

// 생성자 함수로서 호출
new foo(); // -> foo {}

// 메서드로서 호출
var obj = { foo: foo };
obj.foo(); // -> 1
```
- 일반 함수를 생성자 함수로 호출
```js 
var foo = function () {};

// ES6 이전의 모든 함수는 callable이면서 constructor다.
foo(); // -> undefined
new foo(); // -> foo {}
```
- 객체에 바인딩된 함수를 여러가지 방식으로 호출
```js
var obj = {
  x: 10,
  f: function () { return this.x; }
};

// 프로퍼티 f에 바인딩된 함수를 메서드로서 호출
console.log(obj.f()); // 10

// 프로퍼티 f에 바인딩된 함수를 일반 함수로서 호출
var bar = obj.f;
console.log(bar()); // undefined

// 프로퍼티 f에 바인딩된 함수를 생성자 함수로서 호출
console.log(new obj.f()); // f {}
```

이러한 문제점을 해결하기 위해 ES6에서는 함수를 사용 목적에 따라 세가지 종류로 명확히 구분했다.

그림 26
## 26.2 메서드
일반적으로 메서드는 객체에 바인딩된 함수를 일컫는 의미로 사용됐다.
**ES6 사양에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미한다**
```js
const obj = {
  x: 1,
  // 메서드 축약표현 - foo는 메서드이다.
  foo() { return this.x; },
  // bar에 바인딩된 함수는 메서드가 아닌 일반 함수이다.
  bar: function() { return this.x; }
};

console.log(obj.foo()); // 1
console.log(obj.bar()); // 1
```
- ES6의 메서드는 인스턴스를 생성할 수 없고(`non-constructor`), 생성자 함수로서 호출할 수 없다.
```js
// 메서드
new obj.foo(); // -> TypeError: obj.foo is not a constructor
// 일반함수
new obj.bar(); // -> bar {}
```

- ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 `[[HomeObject]]`를 가져서 `super`키워드를 사용할 수 있다 (p. 459)

## 26.3 화살표 함수
표현뿐만 아니라 내부 동작도 기존 함수의 비해서 간략하다.

- 화살표 함수는 인스턴스를 생성할 수 없는 `non-constructor`, 생성자 함수로서 호출할 수 없다.
- 중복된 매개변수 이름을 선언할 수 없다.
- 함수 자체의 `this`, `arguments`, `super`, `new.target` 바인딩을 갖지 않는다.

**화살표 함수는 함수 자체의 `this` 바인딩이 없기 때문에 스코프 체인을 따라 상위스코프의 `this`를 참조한다**

이러한 특징은 "콜백 함수 내부의 this 불일치 문제"를 해결한다.

**콜백 함수와 클래스의 this 불일치 예시**
```js
class Prefixer {
  constructor(prefix) {
    this.prefix = prefix;
  }

  add(arr) {
    // add 메서드는 인수로 전달된 배열 arr을 순회하며 배열의 모든 요소에 prefix를 추가한다.
    // ①
    return arr.map(function (item) {
      return this.prefix + item; // ②
      // -> TypeError: Cannot read property 'prefix' of undefined
    });
  }
}

const prefixer = new Prefixer('-webkit-');
console.log(prefixer.add(['transition', 'user-select']));
```
class 내부에서는 strict mode가 적용되고, strict mode에서 일반 함수로서 호출된 모든 함수 내부의 this는 전역객체가 아니라 `undefined`가 할당된다.

콜백함수 내부에서 `this`는 `undefined`가 할당된다.

**화살표 함수를 사용하는 예시**
```js
class Prefixer {
  constructor(prefix) {
    this.prefix = prefix;
  }

  add(arr) {
    return arr.map(item => this.prefix + item);
  }
}

const prefixer = new Prefixer('-webkit-');
console.log(prefixer.add(['transition', 'user-select']));
// ['-webkit-transition', '-webkit-user-select']
```


## 26.4 Rest 파라미터
## 26.5 매개변수 기본값

