# 21장 빌트인 객체
## 21.1 자바스크립트 객체의 분류
- 표준 빌트인 객체
  - ECMAScript 사양에 정의된 객체, 실행 환경과 관련없이 사용할 수 있음
- 호스트 객체
  - 사양에는 없지만 실행환경에서 제공하는 객체
    - 브라우저 환경: DOM, BOM, Canvas, fetch, SVG ... 와 같은 Web API
    - 서버 환경(Node.js)
- 사용자 정의 객체: 사용자가 정의한 객체
## 21.2 표준 빌트인 객체

- `Object`, `String`, `Number`, `Boolean`, `Symbol`, `Date`, `Array` `Map/Set` 등 40여개
- `Math`, `Reflect`, `JSON`을 제외한 표준 빌트인 객체는 모두 생성자 함수 객체
- 빌트인 객체의 생성자 함수로 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 `prototype` 프로퍼티에 바인딩된 객체
    - e.g. `String`의 인스턴스의 프로토타입은 `String.prototype`
    - 인스턴스 없이도 호출 가능한 정적 메서드 제공
        - e.g. `Number.isInteger`

## 21.3 원시값과 래퍼 객체
문자열이나 숫자, 불리언 등의 원시값이 있는데도, 이를 생성하는 `String`, `Number`, `Boolean`등의 표준 빌트인 생성자 함수가 있는 이유는? 
-> 원시값을 해당 객체로 변환하고, 메서드를 상속받기 위해서

- 원시값에 객체처럼 마침표 표기법으로 접근하면 JS 엔진이 일시적으로 원시값을 연관된 객체로 변환한다.
- 이렇게 생성되는 임시 객체를 **래퍼 객체**<sup>wrapper object</sup>라 한다.
- `String`의 경우 래퍼 객체에 `[[StringData]]` 내부 슬롯에 원시값을 할당한다.
- `String.prototype`의 메서드를 상속받아 사용할 수 있다.
- 래퍼 객체의 처리가 종료되면, 내부슬롯에 원시값으로 식별자를 되돌리고 래퍼 객체는 가비지 컬렉션의 대상이 된다.
- 래퍼 객체가 있기 때문에, `String, Number, Boolean` 생성자 함수를 `new` 연산자와 함께 호출하는 것을 권장하지 않는다.
```js
// ① 식별자 str은 문자열을 값으로 가지고 있다.
const str = 'hello';

// ② 식별자 str은 암묵적으로 생성된 래퍼 객체를 가리킨다.
// 식별자 str의 값 'hello'는 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된다.
// 래퍼 객체에 name 프로퍼티가 동적 추가된다.
str.name = 'Lee';

// ③ 식별자 str은 다시 원래의 문자열, 즉 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값을 갖는다.
// 이때 ②에서 생성된 래퍼 객체는 아무도 참조하지 않는 상태이므로 가비지 컬렉션의 대상이 된다.

// ④ 식별자 str은 새롭게 암묵적으로 생성된(②에서 생성된 래퍼 객체와는 다른) 래퍼 객체를 가리킨다.
// 새롭게 생성된 래퍼 객체에는 name 프로퍼티가 존재하지 않는다.
console.log(str.name); // undefined

// ⑤ 식별자 str은 다시 원래의 문자열, 즉 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값을 갖는다.
// 이때 ④에서 생성된 래퍼 객체는 아무도 참조하지 않는 상태이므로 가비지 컬렉션의 대상이 된다.
console.log(typeof str, str); //string Lee
```
## 21.4 전역 객체

전역 객체<sup>global object</sup>는 런타임 이전에 생성되는 최상위 객체
- 자바스크립트 환경에 따라 이름이 다르다.
    - 브라우저 환경에서는 `window` (또는 `self, this, frames`)
    - Node.js 환경에서는 `global`
- ES11에서 도입된 `globalThis`는 항상 해당 환경의 전역 객체를 가리킨다(전역객체 그자체가 아니라, 전역 실행 컨텍스트의 `this`에 바인딩된 전역객체에 대한 참조)

- 최상위 객체
  - 프로토타입 상속 관계상 최상위라는 의미가 아님
  - 표준 빌트인 객체와 호스트 객체를 프로퍼티로 소유 (Object, String, Number, Promise ...)
  - 프로퍼티 참조시 window(global)을 생략가능
```js
// 문자열 'F'를 16진수로 해석하여 10진수로 변환하여 반환한다.
window.parseInt('F', 16); // -> 15
// window.parseInt는 parseInt로 호출할 수 있다.
parseInt('F', 16); // -> 15

window.parseInt === parseInt; // -> true
```

- `var`로 선언한 변수, 암묵적 전역, 전역 함수는 전역 객체의 프로퍼티가 된다.
- `let`, `const` 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.

```js
// var 키워드로 선언한 전역 변수
var foo = 1;
console.log(window.foo); // 1

// 선언하지 않은 변수에 값을 암묵적 전역. bar는 전역 변수가 아니라 전역 객체의 프로퍼티다.
bar = 2; // window.bar = 2
console.log(window.bar); // 2

// 전역 함수
function baz() { return 3; }
console.log(window.baz()); // 3

// let 키워드로 선언한 전역 변수
let foo = 123;
console.log(window.foo); // undefined
```

### 전역 객체가 소유한 프로퍼티
- 빌트인 전역 프로퍼티
    - `Infinity`
    - `NaN`
    - `undefined`
- 빌트인 전역 함수
    - `eval`
    - `isFinite`
    - `isNaN`
    - `parseFloat`
    - `encodeURI` / `decodeURI`
        - 완전한 URI를 전달받아 인코딩, 이스케이프 처리(아스키 문자셋으로 변환) / 디코딩    
    - `encodeURIComponent` / `decodeURIComponent`
        - URI의 구성요소를 전달받아 인코딩, 이스케이프 처리 / 디코딩
- 암묵적 전역<sup>implicit global</sup>
    - 선언하지 않은 변수에 값을 할당하면, 참조 에러가 발생하지 않고 전역 객체에 해당 프로퍼티를 동적으로 생성한다. 해당 변수는 마치 전역 변수 처럼 동작한다.
    - 변수 호이스팅이 발생하지 않는다.
    - `delete`로 전역 객체에서 삭제할 수 있다. (전역 변수는 불가능)
```js
// 전역 변수 x는 호이스팅이 발생한다.
console.log(x); // undefined
// 전역 변수가 아니라 단지 전역 객체의 프로퍼티인 y는 호이스팅이 발생하지 않는다.
console.log(y); // ReferenceError: y is not defined

var x = 10; // 전역 변수

function foo () {
  // 선언하지 않은 식별자에 값을 할당
  y = 20; // window.y = 20;
}
foo();

// 선언하지 않은 식별자 y를 전역에서 참조할 수 있다.
console.log(x + y); // 30

delete x; // 전역 변수는 삭제되지 않는다.
delete y; // 프로퍼티는 삭제된다.

console.log(window.x); // 10
console.log(window.y); // undefined
```