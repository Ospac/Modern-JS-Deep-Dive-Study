# 24장 클로저
자바스크립트 고유의 개념이 아니라, 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특징이다.
> **MDN에서의 클로저 정의**
클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

**함수가 선언된 렉시컬 환경**이 핵심 키워드


## 24.1 렉시컬 스코프

자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 **함수를 어디에 정의했는지**에 따라 상위 스코프를 결정한다. 이를 **렉시컬 스코프**(정적 스코프)라 한다. (13.5)

```js
const x = 1;

function foo() {
  const x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```
위 예제에서 `foo`와 `bar`의 상위 스코프는 전역 스코프다.
- 스코프의 실체는 실행 컨텍스트의 렉시컬 환경이다. (렉시컬 환경 -> 환경 레코드, 외부 참조)
- **스코프 체인**: 렉시컬 환경은 자신의 *외부 렉시컬 환경에 대한 참조*를 통해 상위 렉시컬 환경과 연결된다.
- **렉시컬 스코프**: 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다.
## 24.2 함수 객체의 내부슬롯 `[[Environment]]`
함수는 자신의 내부슬롯 `[[Environment]]`에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장한다. (p. 379)
- `[[Environment]]`에 저장되는 참조는 함수 정의가 평가되는 시점에 저장된다.(함수 정의 평가 -> 함수 실행)
- 함수가 호출되었을 때 생성될 함수 렉시컬 환경의 "외부 렉시컬 환경에 대한 참조"에는 `[[Environment]]` 내부 슬롯의 참조값을 할당한다.

```js
const x = 1;

function foo() {
  const x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```
위 예제의 `bar` 함수가 호출되어 실행 중인 시점의 실행 컨텍스트는 다음과 같다.

<img width="1280" height="803" alt="24-1" src="https://github.com/user-attachments/assets/613f65a3-49b6-46c1-b1c6-69b56681f91c" />

두 함수는 모두 전역에서 함수 선언문으로 정의되었기 때문에, 전역 코드가 평가되는 시점에 평가되어 함수 객체를 생성, 전역 객체 `window`의 메서드가 된다.

`[[Environment]]` 내부 슬롯은 **함수 정의가 평가된 시점에 실행중인 실행 컨텍스트의 렉시컬 환경**인 *전역 렉시컬 환경의 참조*가 저장된다.
## 24.3 클로저와 렉시컬 환경
> **MDN에서의 클로저 정의**
클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

해당 정의에서 '함수가 선언된 렉시컬 환경'은 **상위 스코프**(함수가 정의된 위치의 실행컨텍스트의 렉시컬 환경)을 의미한다.

- 함수는 상위 스코프를 기억하고, 상위 스코프의 식별자를 참조하고 값을 변경할 수 있다.
- 이때 저장된 상위 스코프는 함수가 존재하는 한 유지된다.
- 외부 함수보다 내부 함수가 더 오래 유지되는 경우(함수가 다른 함수를 반환하는 경우) 내부 함수는 **생명주기가 다한 외부 함수의 변수를 참조**할 수 있다. 이러한 내부 함수를 **클로저**<sup>closure</sup>라고 부른다.

```js
const x = 1;

// ①
function outer() {
  const x = 10;
  const inner = function () { console.log(x); }; // ②
  return inner;
}
// outer 함수를 호출하면 중첩 함수 inner를 반환한다.
// 그리고 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 팝되어 제거된다.
const innerFunc = outer(); // ③
innerFunc(); // ④ 10
```
- ① `outer` 함수가 평가되어 함수 객체를 생성한다.
    - 전역 렉시컬 환경을 `outer`의 `[[Environment]]` 내부 슬롯에 상위 스코프로서 저장한다.
- ② `outer` 함수 실행, 함수표현식 `inner`가 런타임에 평가된다.
    - `outer`함수의 렉시컬 환경을 `inner`의 `[[Environment]]` 내부 슬롯에 상위 스코프로서 저장한다.
- ③ `outer` 함수 생명주기 종료, `inner` 함수 반환
    - `outer`를 실행컨텍스트 스택에서 제거
    - `innerFunc`->`inner` -> `outer` 참조관계가 생겨 `outer`의 렉시컬환경이 없어지지 않음
- ④ `inner` 함수 실행, 실행 컨텍스트 생성, 외부 참조 할당

<img width="1267" height="690" alt="24-5" src="https://github.com/user-attachments/assets/f6fcaf6b-283a-42b8-a4d7-45e052e006d4" />

### 모든 함수가 클로저는 아니다.
모든 함수는 상위 스코프를 기억하므로 이론적으로 모든 함수는 클로저다.

- 내부 함수가 상위 스코프의 식별자를 참조하지 않으면, 모던 브라우저는 최적화를 통해 상위 스코프를 기억하지 않고 클로저를 생성하지 않는다.

- 내부 함수가 상위 스코프를 식별자를 참조하고 있으나, 외부 함수보다 일찍 소멸되면(반환되지 않으면) 생명주기가 종료된 외부 함수의 식별자를 참조할 수 있다는 클로저의 본질에 부합하지 않는다.

> [!NOTE]
> "클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다."
> - 생명 주기가 종료된 외부 함수의 식별자를 참조할 수 있다 (참조 해야한다)
> - 내부 함수가 외부 함수보다 더 오래 유지된다.

클로저에 의해 참조되는 상위 스코프의 변수는 자유 변수<sup>free variable</sup>라 부른다.
- 클로저라는 뜻은 '함수가 자유변수에 닫혀있다(묶여있다)'를 의미한다.
- 클로저가 참조하고 있지 않는 식별자는 메모리에 저장하지 않는다.
## 24.4 클로저의 활용

- 클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다.
- 상태가 의도치 않게 변경되지 않도록 은닉하고, 특정 함수에게만 상태 변경을 허용한다.

전역 변수 코드
- `num`이 전역 변수로 관리되고 있어, 의도치 않게 상태가 변경될 수 있다.
- 오직 `increase` 함수를 통해서만 `num`이 변경되어야 한다.
```js
// 카운트 상태 변수
let num = 0;

// 카운트 상태 변경 함수
const increase = function () {
  // 카운트 상태를 1만큼 증가 시킨다.
  return ++num;
};

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

클로저 활용 코드
- 클로저의 상위 스코프는 즉시 실행 함수로, 변수 참조를 전달하는 것으로 한 번만 실행된다.
- `num` 변수는 외부에서 직접 접근할 수 없는 private 변수가 된다.
```js
// 카운트 상태 변경 함수
const increase = (function () {
  // 카운트 상태 변수
  let num = 0;

  // 클로저
  return function () {
    // 카운트 상태를 1만큼 증가 시킨다.
    return ++num;
  };
}());

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

(24-13 생성자 함수 예제 생략)



#### 함수형 프로그래밍에서 클로저를 활용하는 예제
- 클로저는 외부 상태 변경, 가변 데이터를 피하고 불변성을 지향하는 함수형 프로그래밍에서 적극 활용된다.

```js
// 함수를 인수로 전달받고 함수를 반환하는 고차 함수
// 이 함수는 카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저를 반환한다.
function makeCounter(predicate) {
  // 카운트 상태를 유지하기 위한 자유 변수
  let counter = 0;

  // 클로저를 반환
  return function () {
    // 인수로 전달 받은 보조 함수에 상태 변경을 위임한다.
    counter = predicate(counter);
    return counter;
  };
}

// 보조 함수
function increase(n) {
  return ++n;
}

// 보조 함수
function decrease(n) {
  return --n;
}

// 함수로 함수를 생성한다.
// makeCounter 함수는 보조 함수를 인수로 전달받아 함수를 반환한다
const increaser = makeCounter(increase); // ①
console.log(increaser()); // 1
console.log(increaser()); // 2

// increaser 함수와는 별개의 독립된 렉시컬 환경을 갖기 때문에 카운터 상태가 연동하지 않는다.
const decreaser = makeCounter(decrease); // ②
console.log(decreaser()); // -1
console.log(decreaser()); // -2
```
- `makeCounter` 함수는 인자로 전달받은 보조 함수를 합성하여 자신이 반환하는 함수의 동작을 변경할 수 있다.
- `makeCounter`를 호출해 반환된 함수는 독립된 렉시컬 환경을 갖는다.
## 24.5 캡슐화와 정보 은닉
- **캡슐화**<sup>encapsulation</sup>은 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작하는 동작인 메서드를 하나로 묶는 것을 말한다.
- 캡슐화는 객체의 특정 프로퍼티나 메서드를 외부에 감출 목적으로 사용되기도 하는데 이를 **정보 은닉**이라 한다.
    - 정보 은닉은 프로퍼티나 메서드의 외부 참조를 막고, 객체의 상태가 외부로 부터 변경되는 것을 방지하여 객체 간의 **결합도**를 낮춘다. (다른 객체로부터 상태 변경 가능성을 없앰)
    - 보편적인 객체지향 프로그래밍 언어는 접근 제한자를 제공한다.
    - 자바스크립트의 모든 프로퍼티와 메서드는 기본적으로 `public`하다.

프로토타입 메서드와 클로저를 활용하여 정보 은닉을 구현

```js
const Person = (function () {
  let _age = 0; // private

  // 생성자 함수
  function Person(name, age) {
    this.name = name; // public
    _age = age;
  }

  // 프로토타입 메서드
  Person.prototype.sayHi = function () {
    console.log(`Hi! My name is ${this.name}. I am ${_age}.`);
  };

  // 생성자 함수를 반환
  return Person;
}());

const me = new Person('Lee', 20);
me.sayHi(); // Hi! My name is Lee. I am 20.
console.log(me.name); // Lee
console.log(me._age); // undefined

const you = new Person('Kim', 30);
you.sayHi(); // Hi! My name is Kim. I am 30.
console.log(you.name); // Kim
console.log(you._age); // undefined
```
- 하지만, `Person.prototype.sayHi` 메서드는 단 한번만 생성된다. 해당 메서드의 상위 스코프는 어떤 인스턴스로 호출하더라도 하나의 동일한 상위스코프를 사용하게 된다.
- `Person` 생성자 함수가 여러 개의 인스턴스를 생성할 경우, `_age` 변수의 상태가 유지되지 않는다.

```js
const me = new Person('Lee', 20);
me.sayHi(); // Hi! My name is Lee. I am 20.

const you = new Person('Kim', 30);
you.sayHi(); // Hi! My name is Kim. I am 30.

// _age 변수 값이 변경된다!
me.sayHi(); // Hi! My name is Lee. I am 30.
```


## 24.6 자주 발생하는 실수

`var` 키워드로 선언한 변수를 참조하는 함수
- `var` 변수는 함수레벨 스코프를 가져서 참조하는 시점에는 전역변수
```js
var funcs = [];

for (var i = 0; i < 3; i++) {
  funcs[i] = function () { return i; }; // ①
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]()); // ② 3 3 3
}
```
클로저로 개선

```js
var funcs = [];

for (var i = 0; i < 3; i++){
  funcs[i] = (function (id) { // ①
    return function () {
      return id;
    };
  }(i));
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]());
}
```

첫번째 예제에서 블록레벨 스코프를 가지는 `let`, `const`를 사용하면 고차함수를 사용할 필요가 없다.
- for문의 코드블록이 반복 실행될 때마다 식별자의 값을 유지해야한다. (`let`으로 선언된 `i`가 해당 코드블록이 종료되면 사라지지만 참조를 유지하고 있으므로)
- 이를 위해 독립적인 렉시컬 환경이 생성된다.
```js
const funcs = [];

for (let i = 0; i < 3; i++) {
  funcs[i] = function () { return i; };
}

for (let i = 0; i < funcs.length; i++) {
  console.log(funcs[i]()); // 0 1 2
}
```
