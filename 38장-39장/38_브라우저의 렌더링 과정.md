# 38장 브라우저의 렌더링 과정
자바스크립트는 자바스크립트 런타임 환경인 Node.js의 등장으로 서버 사이드 어플리케이션 개발에도 사용하는 범용 개발 언어가 되었지만, 여전히 웹 브라우저 환경에서 동작하는 클라이언트 사이드에서 주로 사용된다.

이 장은 브라우저가 어떻게 HTML, CSS, 자바스크립트로 작성된 문서를 파싱(해석)하여 브라우저에 렌더링하는지를 다룬다. 

브라우저의 렌더링 과정<sup>critical rendering path</sup>을 간략하게 표현한 그림
그림 38-1 

1. 브라우저는 HTML, CSS, JS, 이미지, 폰트 파일 등 **렌더링에 필요한 리소스를 요청**하고 서버로부터 응답 받는다.
2. 렌더링 엔진은 응답된 HTML, CSS를 파싱하여 **DOM과 CSSOM을 생성**하고 둘을 결합하여 **렌더 트리를 생성**한다.
3. 자바스크립트 엔진은 응답받은 **자바스크립트를 파싱**하여 AST<sup>Abstract Syntaxt Tree</sup>를 생성하고 바이트 코드로 변환하여 **실행**한다. 이때 JS는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있다. 변경된 DOM, CSSOM은 다시 렌더 트리로 결합된다
4. 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)을 계산하고 **브라우저 화면에 HTML 요소를 페인팅**한다.

## 38.1 요청과 응답
브라우저의 핵심 기능은 필요한 리소스를 서버에 **요청**하고 **응답**받아 **파싱**하여 브라우저에 시각적으로 **렌더링**하는 것이다.

서버에 요청하기 위해서 서버에 대한 URL이 필요하다.

그림 38-2

**요청 과정**
1. 브라우저 주소창에 URL을 입력하고 엔터 키를 누른다.
2. URL의 호스트 이름이 DNS를 통해 IP 주소로 변환된다.
3. 해당 IP 주소를 갖는 서버에게 요청을 전송한다.

> [!NOTE]
> https://poiemaweb.com 의 예시
> - path를 생략하면, 일반적으로 서버는 루트 요청에 대해 암묵적으로 `index.html`을 응답한다. (https://poiemaweb.com/index.html)
> - 다른 정적 파일을 요청하기 위해서는 path를 작성한다.
> https://poiemaweb.com/assets/data/data.json (~/assets/data.json 파일 요청)
> 자바스크립트를 통해서 서버에 정적/동적 데이터를 요청할 수도 있다.(43장 ajax, 44장 REST API)

## 38.2 HTTP 1.1과 HTTP 2.0
HTTP<sup>HyperText Transfer Protocol</sup>는 웹에서 브라우저와 서버가 통신하기 위한 프로토콜이다.
- HTTP/1.0 (1996)

그림 38-4
- HTTP/1.1 (1999)
    - 커넥션당 하나의 요청과 응답만 처리한다.
    - 요청할 리소스의 개수에 비례하여 응답 시간도 증가한다.

그림 38.5
- HTTP/2 (2015)
    - 여러 리소스의 동시 전송이 가능하여 속도가 개선되었다.
## 38.3 HTML 파싱과 DOM 생성
브라우저 요청에 서버가 응답한 HTML 문서는 브라우저가 이해할 수 있는 자료구조(DOM)으로 변환된다.

- 브라우저의 렌더링 엔진은 다음 코드를 파싱하여 토큰을 생성하고 각 토큰들을 객체로 변환하여 노드를 생성한다. 
- HTML 요소의 중첩관계에 따라 노드는 트리 자료구조로 구성되며 DOM<sup>Document Object Model</sup>을 생성한다.

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
    <script src="app.js"></script>
  </body>
</html>
```

## 38.4 CSS 파싱과 CSSOM 생성
렌더링 엔진은 HTML 문서를 한 줄씩 차례대로 파싱하여 DOM을 생성한다. 이때 CSS를 로드하는 `link`, `style` 태그를 만나면 DOM 생성을 중지하고, CSSOM 생성을 시작한다. 
- `link` 태그의 `href` 어트리뷰트에 지정된 CSS파일을 서버에 요청하고 응답받는다.
- `style` 태그의 경우 내부를 읽는다.
    - CSS는 HTML과 동일한 파싱 과정(바이트 -> 문자 -> 토큰 -> 노드 -> CSSOM)을 통해 **CSSOM**<sup>CSS Object Model</sup>을 생성한다. 
    - CSSOM은 CSS의 상속관계를 반영하여 생성된다.

그림 38-7

## 38.5 렌더 트리 생성

그림 38-8

DOM과 CSSOM은 렌더링을 위해 **렌더 트리**로 결합된다.

그림 38-9 

- 완성된 렌더 트리는 각 HTML 요소의 레이아웃(위치와 크기)을 계산하는 데 사용된다.
- 이후 레이아웃 값을 통해 브라우저 화면에 픽셀을 렌더링하는 페인팅 단계가 이루어진다.

다음과 같은 경우 레이아웃 계산과 페인팅이 다시 실행된다. 
웹사이트의 성능을 위해 리렌더링이 빈번하게 발생하지 않도록 주의할 필요가 있다.

- 자바스크립트에 의한 노드 추가 또는 삭제
- 브라우저 창의 리사이징에 의한 뷰포트 크기 변경
- HTML 요소의 레이아웃을 변경하는 스타일 변경 (`width/height, margin, padding, border, display, position, top/right/bottom/left` 등)

## 38.6 자바스크립트 파싱과 실행

CSS 파싱과 마찬가지로 렌더링 엔진이 HTML 문서를 파싱하여 DOM을 생성하다가 `script` 태그를 만나면 
- `src`에 정의된 자바스크립트 파일을 서버에 요청하여 응답받거나
- 내부 자바스크립트 코드에 접근한다.

렌더링 엔진은 자바스크립트 엔진에 제어권을 넘기고, JS 코드를 파싱한다.
코드는 변환(코드 -> 토큰 -> AST -> 바이트코드)을 거쳐 인터프리터가 실행한다.

그림 38-10

## 38.7 리플로우와 리페인트

자바스크립트 코드에서 DOM이나 CSSOM을 변경하는 DOM API를 호출하면 변경된 DOM, CSSOM을 기반으로 다시 렌더트리를 생성, 레이아웃, 페인트 단계를 거쳐 다시 화면을 렌더링한다. 

- 리플로우: 레이아웃 계산을 다시
- 리페인트: 다시 화면을 페인트 (레이아웃에 영향 없는 변경은 리페인트만 실행됨)

> [!NOTE]
> `<img />` 태그에 `width`, `height`를 명시하지 않으면 이미지 다운로드 이후에 레이아웃부터 재계산됨 (reflow)

## 38.8 자바스크립트 파싱에 의한 HTML 파싱 중단
렌더링 엔진, 자바스크립트 엔진은 다음과 같이 직렬적으로 파싱을 수행한다.

그림 38-13 

- 브라우저는 동기적으로 HTML, CSS, JS를 파싱하고 실행하기 때문에, `script`는 HTML 파싱을 블로킹하여 DOM 생성을 지연시킬 수 있다.
- 따라서 `script` 태그의 위치는 중요하다.
     - 자바스크립트 코드에서 DOM API를 이용하여 아직 생성되지 않은 DOM에 접근하면 오류가 발생한다.
     - DOM API를 사용하는 `script` 태그는 `body` 요소 하단에 위치시키는 것이 해결책 중 하나

> [!NOTE]
>  `script` 태그는 `body` 요소 하단에 위치시키는 것의 문제점
> 서버에 자바스크립트를 요청하는 경우 브라우저가 HTML 문서 요청, 응답, 파싱을 처리한 이후 자바스크립트를 서버로부터 다운로드 받기 때문에 페이지가 느려진다.

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css">
    <script>
      /*
      DOM API인 document.getElementById는 DOM에서 id가 'apple'인 HTML 요소를
      취득한다. 아래 DOM API가 실행되는 시점에는 아직 id가 'apple'인 HTML 요소를 파싱하지
      않았기 때문에 DOM에는 id가 'apple'인 HTML 요소가 포함되어 있지 않다.
      따라서 아래 코드는 정상적으로 id가 'apple'인 HTML 요소를 취득하지 못한다.
      */
      const $apple = document.getElementById('apple');

      // id가 'apple'인 HTML 요소의 css color 프로퍼티 값을 변경한다.
      // 이때 DOM에는 id가 'apple'인 HTML 요소가 포함되어 있지 않기 때문에 에러가 발생한다.
      $apple.style.color = 'red'; // TypeError: Cannot read property 'style' of null
    </script>
  </head>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
  </body>
</html>
```

## 38.9 script 태그의 async/defer 어트리뷰트

- 자바스크립트 파싱에 의한 DOM 생성이 중단 blocking 되는 문제를 근본적으로 해결하기 위해 HTML5부터 `script` 태그에 `async/defer` 어트리뷰트가 추가되었다.
- `src`로 외부 자바스크립트 파일을 로드하는 경우에만 사용할 수 있다.

```html
<script async src="extern.js"></script>
<script defer src="extern.js"></script>
```


### async 어트리뷰트
그림 38-14

- HTML 파싱과 외부 JS 파일의 로드가 비동기적으로 동시에 진행된다.
- JS의 파싱과 실행은 JS 로드가 완료된 직후에 진행되고, HTML 파싱은 중단된다.
- 여러 개의 `script` 태그에 `async` 어트리뷰트를 지정하면 로드가 완료된 JS부터 실행되므로 실행 순서가 보장되지 않는다.


### defer 어트리뷰트
그림 38-15

- HTML 파싱과 외부 JS 파일의 로드가 비동기적으로 동시에 진행된다.
- JS의 파싱과 실행은 DOM 생성이 완료된 직후(`DOMContentLoaded` 이벤트가 발생하기 전)에 진행된다.


> [!NOTE]
> - async와 defer 스크립트는 다운로드 시 페이지 렌더링을 막지 않는다는 공통점이 있습니다. 따라서 async와 defer를 적절히 사용하면 사용자가 오래 기다리지 않고 페이지 콘텐츠를 볼 수 있게 할 수 있습니다.
> - 비동기 스크립트는 방문자 수 카운터나 광고 관련 스크립트처럼 각각 독립적인 역할을 하는 서드 파티 스크립트를 현재 개발 중인 스크립트에 통합하려 할 때 아주 유용합니다. async 스크립트는 개발 중인 스크립트에 의존하지 않고, 그 반대도 마찬가지이기 때문입니다.
> https://ko.javascript.info/script-async-defer
