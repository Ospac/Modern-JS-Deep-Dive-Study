# 23장 실행 컨텍스트
**실행 컨텍스트**<sup>execution context</sup>는 자바스크립트 코드를 실행하는데 필요한 환경, 상태(스코프, 변수, 특정 객체등)를 구성하는 객체다. 
- 식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다. (364p)
- 식별자 결정<sup>identifier resolution</sup> (191p)을 효율적으로 하기 위한 수단이 된다.
- 실행 컨텍스트 스택과 렉시컬 환경으로 구성된다.
## 23.1 소스코드의 타입
소스코드의 타입마다 실행 컨텍스트를 생성하는 과정과 관리 내용이 다르다.
- 전역 코드 -> **전역 실행 컨텍스트**
  - 전역 변수, 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩한다.
- 함수 코드 -> **함수 실행 컨텍스트**
    - 함수 지역 스코프, 지역 변수, 매개 변수, arguments 객체등을 관리
    - 생성한 지역 스코프들을 전역 스코프에서 이어지는 스코프 체인으로 연결한다.
- eval 코드 -> eval 실행 컨텍스트
- 모듈 코드 -> 모듈 실행 컨텍스트
    - 모듈별로 독립적인 모듈 스코프 생성
## 23.2 소스코드의 평가와 실행  
모든 소스 코드는, **소스코드의 평가**, **소스코드의 실행 과정**을 거친다.
1. 소스코드의 평가
- 실행 컨텍스트를 생성
- 변수, 함수등의 선언문만 먼저 실행하여 해당 식별자를 키로 실행 컨텍스트의 스코프에 등록한다. (호이스팅)
2. 소스코드의 실행 과정 (런타임)
- 소스코드를 순차적으로 실행
- 소스코드 실행에 필요한 정보, 변수나 함수의 참조등을 실행 컨텍스트의 스코프에서 검색해서 사용한다.
- 변수 값 변경, 실행 결과 등은 실행 컨텍스트 스코프에 반영된다.

```js
var x;
x = 1;
```
1. 소스코드 평가 과정에서 선언문 `var x;`를 먼저 실행, 실행 컨텍스트 스코프에 등록, `undefined` 초기화
2. 소스코드 실행 과정 시작, 할당문 `x = 1` 만 실행
3. 실행 컨텍스트의 스코프에서, `x` 변수 참조
4. 해당 변수에 `1`을 할당하고 결과를 컨텍스트에 등록하여 관리

## 23.3 실행 컨텍스트의 역할
- 모든 식별자들은 **스코프를 구분**하여 등록되고 값의 변화가 관리된다.
- 함수의 중첩 관계에 의해 **스코프 체인**을 만들고, 상위 스코프로 이동하여 식별자를 검색한다.
- 전역 객체의 프로퍼티도 전역 변수처럼 검색 가능
- 함수 호출에 의해 실행 순서가 변경된다.
-> **실행 컨텍스트**: 식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.
- 
### 코드의 실행 순서
1. 전역 코드 평가
    - 전역 코드의 **변수 선언문, 함수 선언문**을 먼저 실행, 실행 컨텍스트의 전역 스코프에 등록
2. 전역 코드 실행 (런타임)
    - 전역 코드를 순차적으로 실행, 값이 할당되고 함수가 호출됨
    - 함수가 호출될 경우, 코드 실행은 함수 내부로 진입하여 진행된다. (3)
3. 함수 코드 평가
    - 함수 내부로 진입시, **매개변수, 지역 변수 선언문**을 먼저 실행, 함수 실행 컨텍스트의 지역 스코프에 등록
    - `arguments` 객체 생성
    - `this` 바인딩 결정
4. 함수 코드 실행
    - 매개 변수와, 지역 변수에 **값이 할당**
    - 다른 함수 평가 및 실행
        - 중첩된 함수 내부에 있다면, 스코프 체인을 통해 검색
        - `console`과 같이 전역 객체의 프로퍼티에 있다면 전역 스코프로 접근
## 23.4 실행 컨텍스트 스택 
- 코드의 실행 순서 관리를 위한 컴포넌트
- 소스코드가 평가되면, 실행 컨텍스트가 생성되고 스택의 최상위에 쌓인다.
-> 스택의 최상위에 존재하는 컨텍스트는 언제나 현재 실행중인 코드의 컨텍스트다.

```js
const x = 1;

function foo () {
  const y = 2;

  function bar () {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo(); // 6
```
<img width="947" height="331" alt="02" src="https://github.com/user-attachments/assets/cf00be18-addd-439d-8ac2-c37d58fd3baa" />

## 23.5 렉시컬 환경 (Lexical Environment)
- 실행 컨텍스트를 구성하는 컴포넌트, 스코프와 식별자 관리
- 식별자와 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조

### 렉시컬 환경의 구성요소
- 환경 레코드<sup>Environment Record</sup>
  - 식별자가 키와 값을 갖는 객체 형태로 저장됨
- 외부 렉시컬 환경에 대한 참조<sup>Outer Lexical Environment Reference</sup>
  - 해당 실행 컨텍스트를 생성한 상위 스코프를 가리키는 참조(이와 같은 연결을 통해 **스코프 체인**을 구성)

<img width="813" height="302" alt="image (2)" src="https://github.com/user-attachments/assets/280ee800-d6f7-4339-bbe4-4ce0775fe1e3" />

## 23.6 실행 컨텍스트의 생성과 식별자 검색 과정
```js
var x = 1;
const y = 2;

function foo (a) {
  var x = 3;
  const y = 4;

  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
}
  bar(10);
}

foo(20); // 42
```

### 23.6.1 ~ 23.6.3 전역 코드 
1. 전역 객체 생성
    - 전역 프로퍼티, 빌트인 전역 함수, 표준 빌트인 객체 추가, 동작 환경에 따라 객체 추가( WebAPI, 호스트 객체 ...)
2. 전역 코드 평가

    - 전역 스코프 역할을 하는 **전역 환경 레코드**는 `var`로 선언한 전역 변수와 ES6의 `let`, `const`로 선언한 전역 변수를 구분하여 관리하기 위해 
**객체 환경 레코드**<sup>Object environment record</sup>와 **선언적 환경 레코드**<sup>Declarative Environment Record</sup>로 나뉜다.
    - `var`로 선언된 전역 변수와, 함수 선언문으로 정의된 전역 함수는 `객체 환경 레코드`에 연결된 `BindingObject`를 통해 전역 객체의 프로퍼티와 메서드가 된다.
        - 전역 변수는 암묵적으로 `undefined`가 할당 (변수 호이스팅)
        - 전역 함수는 평가 단계에서 즉시 생성된 함수 객체가 할당된다.(함수 호이스팅)
```js
var x = 1;
const y = 2;
function foo (a) {
  ...
}
```
<이미지>

  - this 바인딩
    - `[[GlobalThisValue]]`에 `this`가 바인딩된다. 전역 코드의 경우 전역 객체를 가리킨다.
  - 전역 코드 상위의 코드는 없으므로, 외부 렉시컬 환경에 대한 참조(outer)는 `null`

3. 전역 코드 실행
      - 식별자에 값이 할당된다. **식별자 결정**을 위해 실행 중인 실행 컨텍스트에서 부터 식별자를 검색한다.
      - 전역 렉시컬 환경은 **스코프 체인**의 종착지로 이곳에서 검색할 수 없는 식별자는 참조에러를 발생시킨다.

4. 함수 코드 평가
    1. 함수 실행 컨텍스트 생성
    2. 함수 렉시컬 환경 생성
        1. 함수 환경 레코드<sup>Function Environment Record</sup>도 생성하여 연결 
        2. this 바인딩
            - `[[ThisValue]]`에 `this`가 바인딩, `foo`와 같은 일반 함수는 전역 객체를 가리킴
        3. 외부 렉시컬 환경에 대한 참조(outer)
            - `foo`는 전역 코드에서 정의된 함수기 때문에, 전역 렉시컬 환경을 참조한다.
            - 참조값을 할당 받을 수 있는 것은 실행중인 함수 객체의 슬롯 ``[[Environment]]``에 상위 스코프의 렉시컬 환경의 참조값이 저장되어있기 때문이다. (24장 클로저)

```js
function foo (a) {
  var x = 3;
  const y = 4;

  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
}
  bar(10);
}
```
<이미지> 23.17

5. 함수 코드 실행
    - 식별자에 값 할당을 위한, **식별자 검색**
        - 현재 실행중인 렉시컬 환경에서부터 시작해서, 참조 값(outer)을 이용하여 상위 스코프의 렉시컬 환경으로 이동하며, 같은 이름의 식별자 검색

6. 함수 코드 실행 종료
    - 모든 코드를 실행한 함수는, 실행 컨텍스트 스택에서 pop하여 제거된다.

## 23.7 실행 컨텍스트와 블록 레벨 스코프

`var` 와 달리 `let` `const` 키워드로 선언한 변수는 블록 레벨 스코프를 따른다.
이러한 변수를 사용할때, 코드 블록을 위한 블록 레벨 스코프를 생성한다.
```js
let x = 1;

if (true) {
  let x = 10;
  console.log(x); // 10
}

console.log(x); // 1
```

이미지 23-28

- 새롭게 생성된 블록 레벨 렉시컬 환경은 기존의 전역 렉시컬 환경을 교체한다.
- 외부 렉시컬 환경에 대한 참조(outer)는 이전의 전역 렉시컬 환경을 가리킨다.
- 블록의 실행이 종료되면, 이전의 렉시컬 환경으로 돌아간다(`LexicalEnvironment`가 `Global Lexical Environment`를 다시 가리킴)

