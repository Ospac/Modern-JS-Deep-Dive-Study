# 14장 전역 변수의 문제점
## 14.1 변수의 생명주기
### 14.1.1 지역 변수의 생명주기
- 지역 변수는 함수 내부에서 선언된 함수다.
    - **지역 변수의 생명주기는 함수의 생명주기와 일치**
    - 함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸한다.
    - 다른 곳에서 스코프를 참조하고 있다면 함수가 종료해도 변수가 담긴 스코프와 변수가 제거되지 않음 (24장 클로저)
    - 호이스팅은 스코프를 단위로 동작한다.
### 14.1.2 전역 변수의 생명주기
- `var` 키워드로 선언한 전역 변수의 생명주기는 전역 객체(`window` or `global`)의 생명 주기와 일치
- 전역 객체 `window`는 웹페이지를 닫기 전까지 유효
## 14.2 전역 변수의 문제점
- 암묵적 결합: 모든 코드가 전역 변수를 참조하고 변경할 수 있다.
- 긴 생명주기: 메모리 리소스 차지, 의도치 않은 재할당의 가능성
- 스코프 체인 상에서 종점에 존재: 함수 내부에서 전역변수 참조시, 검색 속도가 가장 느림
- 네임스페이스 오염

## 14.3 전역 변수의 사용을 억제하는 방법
변수의 스코프는 좁을수록 좋다.

- 즉시 실행 함수: 모든 코드를 즉시 실행 함수를 감싸기 (전역 변수가 없음)
- 네임스페이스 객체: 전역 변수처럼 사용하고 싶은 변수를 등록
```js
var MYAPP = {}; // 전역 네임스페이스 객체

MYAPP.person = {
  name: 'Lee',
  address: 'Seoul'
};

console.log(MYAPP.person.name); // Lee
```
- 모듈 패턴
클로저를 사용하여, 캡슐화를 구현한다.
예시에서는 `num`을 함수 내부에서 혹은 반환하는 함수를 통해서만 접근할 수 있다.
```js
var Counter = (function () {
  // private 변수
  var num = 0;

  // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    }
  };
}());

// private 변수는 외부로 노출되지 않는다.
console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```

- ES6 모듈
    - 파일 자체의 독자적인 모듈 스코프를 제공한다. 파일 내부에서 `var`로 선언한 변수는 전역 변수가 아니고, `window` 객체의 프로퍼티도 아니다.
    - 해당 기능을 직접 사용하기보단, Webpack 등의 모듈 번들러를 사용하는게 일반적
```js
<script type="module" src="lib.mjs"></script>
<script type="module" src="app.mjs"></script>
```