# 19장 프로토타입

자바스크립트는 **프로토타입 기반의 객체지향언어**이다. (이외에도 명령형, 함수형으로 사용될 수 있다.) 자바스크립트를 이루고 있는 거의 모든 것이 객체다.(원시 타입의 값을 제외한 나머지 값들: 함수, 배열, 정규 표현식등)

## 19.1 객체지향 프로그래밍
객체지향 프로그래밍은 프로그램을 명령어 또는 함수의 목록으로 보는 명령형 프로그래밍의 절차지향적 관점에서 벗어나, 여러 개의 독립적 단위인 **객체**의 집합으로 프로그램을 구현하는 패러다임이다.

- 특정 개체가 가지는 속성<sup>attribute/property</sup>들의 목록을 정의한다.
- 객체의 상태를 나타내는 데이터(속성)와 데이터를 조작할 수 있는 동작을 하나의 논리적인 단위로 묶은 자료구조가 객체다.
  - 원의 반지름: 속성(프로퍼티)
  - 원의 지름, 둘레, 넓이를 구하는 것 : 동작(메서드)
- 각 객체는 고유의 기능을 갖는 독립적인 부품이지만, 다른 객체와 메시지를 주고 받거나, 다른 객체의 데이터나 동작을 상속받아 사용하기도 한다.

## 19.2 상속과 프로토타입
상속은 객체지향의 핵심개념, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다.
- 자바스크립트는 프로토타입을 기반으로 상속을 구현하여 코드를 재사용한다.

17.2 에서 다룬 다음 예제에서 중복되는 코드인 `getArea`를 상속으로 처리할 수 있다. 
```js
// 생성자 함수
function Circle(radius) {
  this.radius = radius;
  this.getArea = function () {
    // Math.PI는 원주율을 나타내는 상수다.
    return Math.PI * this.radius ** 2;
  };
}

// 반지름이 1인 인스턴스 생성
const circle1 = new Circle(1);
// 반지름이 2인 인스턴스 생성
const circle2 = new Circle(2);

// Circle 생성자 함수는 인스턴스를 생성할 때마다 동일한 동작을 하는
// getArea 메서드를 중복 생성하고 모든 인스턴스가 중복 소유한다.
// getArea 메서드는 하나만 생성하여 모든 인스턴스가 공유해서 사용하는 것이 바람직하다.
console.log(circle1.getArea === circle2.getArea); // false

console.log(circle1.getArea()); // 3.141592653589793
console.log(circle2.getArea()); // 12.566370614359172
```

프로토타입 기반 상속을 사용하는 코드
- 생성자 함수가 생성한 인스턴스는 해당 함수의 prototype의 모든 프로퍼티와 메서드를 상속받는다.

```js
// 생성자 함수
function Circle(radius) {
  this.radius = radius;
}

// Circle 생성자 함수가 생성한 모든 인스턴스가 getArea 메서드를
// 공유해서 사용할 수 있도록 프로토타입에 추가한다.
// 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다.
Circle.prototype.getArea = function () {
  return Math.PI * this.radius ** 2;
};

// 인스턴스 생성
const circle1 = new Circle(1);
const circle2 = new Circle(2);

// Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는
// 프로토타입 Circle.prototype으로부터 getArea 메서드를 상속받는다.
// 즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메서드를 공유한다.
console.log(circle1.getArea === circle2.getArea); // true

console.log(circle1.getArea()); // 3.141592653589793
console.log(circle2.getArea()); // 12.566370614359172
```

## 19.3 프로토타입 객체
프로토타입은 어떤 객체의 상위(부모) 객체의 역할을 하고, 하위 객체에 공유 프로퍼티를 제공한다.
- 모든 객체는 `[[Prototype]]`이라는 내부 슬롯을 가지며, 이 내부 슬롯의 값은 프로토타입의 참조다.
    - 객체 생성 방식에 따라 해당 슬롯에 저장되는 프로토타입이 다르다. (19.6)
        - 객체 리터럴의 경우 `Object.prototype`
        - 생성자 함수의 경우 `생성자함수.prototpye`
    - 객체와 프로토타입과 생성자 함수는 참조를 통해 서로 연결되어 있다.
    // 그림 19-3
### 19.3.1 __proto__ 접근자 프로퍼티
객체는 `__proto__` 프로퍼티를 통해 자신의 프로토타입 즉 `[[Prototype]]` 내부 슬롯에 간접적으로 접근한다.

// 그림 19-4

`__proto__`는 접근자 프로퍼티기 때문에, 프로토타입에 직접 접근하거나 수정할 수 없다. 대신 접근자 함수`get`, `set` 를 사용하는데, 값에 접근하거나, 값을 할당하면 접근자 함수의 호출이 내부적으로 처리된다.

```js
const obj = {};
const parent = { x: 1 };

// getter 함수인 get __proto__가 호출되어 obj 객체의 프로토타입을 취득
obj.__proto__;
// setter함수인 set __proto__가 호출되어 obj 객체의 프로토타입을 교체
obj.__proto__ = parent;

console.log(obj.x); // 1
```

- 또한 `__proto__`는 객체가 직접 소유하는 프로퍼티가 아니라 `Object.prototype`의 프로퍼티기 때문에 모든 객체는 상속을 통해서 `Object.prototype.__proto__` 접근자 프로퍼티를 사용한다.
- 두개의 객체가 서로를 프로토타입으로 지정해서 순환 참조가 일어나는 일이 없도록, `__proto__` 접근자를 통해 에러를 발생시킨다.
- 

### 19.3.2 함수 객체의 prototype 프로퍼티
함수 객체만이 소유하는 `prototype` 프로퍼티를 통해 생성할 인스턴스의 프로토타입를 가리킨다.
- non-constructor인 화살표 함수와 메서드 축약 표현으로 정의한 메서드는 `prototype` 프로퍼티도 없고, 프로토타입을 생성하지 않는다.



### 19.3.3
프로토타입은 `constructor`를 통해 생성자 함수에 접근한다.

